# UARC

c0 is an official UARC ISA. The purpose of UARC is to make it trivial to combine cores that are specialized at performing their function, so as to alleviate the process of providing backwards compatibility and to provide better utilization. The purpose of c0 is somewhat counter to the purpose of UARC: to provide a general purpose architecture. c0 is designed to be an architecture with high instruction density and the capability to quickly respond to communications from other more-specialized cores. To this end its entire architecture is designed, down to the stack architecture that lets it immediately respond to interrupts.

c0, as a reference UARC implementation, must provide all standard UARC facilities. It must allow multicast interrupts and data streaming. It must also allow privilege delegation. Message passing is facilitated by sending words over the UARC bus or sending a stream over the UARC bus. Sending an interrupt to a core that is not running will cause the interrupt to wait for the core to accept the interrupt by starting. Sending a stream to a target that is currently not running will cause permissions to be delegated to that core and for the core to begin running the program streamed to it.

UARC permissions work in a hierarchy. If a core has incepted a core, it also has **privilege** over all the cores incepted by that core. This means that any children cores can be stopped using the `kill` instruction. Such delegation allows an operating system to not only stop execution of processes, but also delegate permissions to those processes. To achieve this delegation capability, cores continuously share their **permission** and **address** with all targets over the UARC bus so that cores can tell if other cores have **privilege** over them. The only parts of the **address** that are relevant are those masked by the the **permission** of the core. A **permission** of 0 indicates that a core has absolute **privilege** over all cores, including all cores that are of the same privilege level. If the **permission** is all `1`s, then all **address** bits encode the **privilege** of the core, which means such a core can only `kill` cores the exact same **address**.

It is permitted for any core to attempt communications with any other core, regardless of either of their **permission**. However, some cores may have specific schemes to accept or reject communications based on a communicating core's delegated **permission**. For instance, a core might have a table of **permission** values that allow it to filter communications based on a core's parents. In c0, such elaborate systems must be implemented in software, but programmers should be aware that other systems might be capable of this.

`kill` is a simple instruction, but it has a complicated result. All child cores of the core being killed must also be killed. To achieve this, the UARC bus has two lines. One line is for sending a kill signal and the other is for acknowledging completion. As soon as a core knows all children are stopped, it may assert the acknowledge line and stop on the next cycle. A core with no children may immediately assert the acknowledge line and stop as soon as possible, since it has already met the above condition. A side effect of this setup is that the kill signal will also take one cycle to propagate down through each core. It takes `2 * n` cycles to complete the `kill` instruction, depending on the depth of inception (`n`).

A corner case is that a core may try to send a kill signal to a core for which it doesn't have **permission** to kill. In this case, the core should acknowledge immediately without doing anything to prevent deadlock. Also, any core which is already killed should continue to assert the acknowledge line to prevent deadlock in the case that the core is not even running. This also allows cores to know when another core is no longer running, though c0 is not capable of detecting this.
